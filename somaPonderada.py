# -*- coding: utf-8 -*-
"""TD-MonoObj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RLZLvoU9U3Keu0XDAYYxEepfI9kB0Sj-

Grupo:

*   Bernardo Araujo Ribeiro
*   Marcus Vinicius Ferreira Vilela
*   Maria Luiza Coelho Rodrigues
"""

import random
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn.cluster import KMeans
import copy as cp
class Struct:
    pass

"""Dados Clientes"""


file_path = './clientes.csv'
clientes_dataset = pd.read_csv(file_path, header=None, names=['x', 'y', 'bandwidth'])

"""Dados Gerais"""

min_f1 = 5
max_f1 = 25
min_f2 = 5000
max_f2 = 50000

class ProblemData:
    def __init__(self, clients, max_p_as, pa_capacity, max_distance, lambda_exposure, gamma):
        self.clients = clients
        self.max_p_as = max_p_as
        self.pa_capacity = pa_capacity
        self.max_distance = max_distance
        self.lambda_exposure = lambda_exposure
        self.gamma = gamma
        self.pas = []  # To store access point positions
        self.assignments = []  # To store access point positions

    def initialize_solution(self, use_constructive_heuristic=True, qtd_pas_inicial=20):
        np.random.seed(42)  # For reproducibility
        grid_spacing = 5  # Grid spacing in meters

        if use_constructive_heuristic:

            # Número de PAs (pontos de acesso) desejados
            num_pas = qtd_pas_inicial

            # Defina a área e o intervalo do grid
            area_size = 400
            grid_interval = 5

            # Crie os pontos do grid
            grid_points = [(i, j) for i in range(0, area_size + grid_interval, grid_interval)
                            for j in range(0, area_size + grid_interval, grid_interval)]
            grid_points = np.array(grid_points)

            # Execute o K-means
            kmeans = KMeans(n_clusters=num_pas, random_state=0).fit(clientes_dataset[['x','y']])

            # Obtenha os centros dos clusters (onde os PAs serão colocados)
            centros = kmeans.cluster_centers_

            # Função para encontrar o ponto do grid mais próximo
            def find_nearest_grid_point(point, grid_points):
                distances = np.sqrt((grid_points[:, 0] - point[0])**2 + (grid_points[:, 1] - point[1])**2)
                nearest_index = np.argmin(distances)
                return grid_points[nearest_index]

            # Encontre os pontos do grid mais próximos dos centros dos clusters
            nearest_grid_points = np.array([find_nearest_grid_point(centro, grid_points) for centro in centros])

            for i in range(len(nearest_grid_points)):
                x = nearest_grid_points[i][0]
                y = nearest_grid_points[i][1]
                self.pas.append((x, y))


            while len(self.pas) < self.max_p_as :
                x = 999
                y = 999
                self.pas.append((x,y))
                i +=1;


        else:
            # Randomly distribute access points within the convention center area
            area_width = 400
            grid_points_x = np.arange(0, area_width + 1, grid_spacing)
            grid_points_y = np.arange(0, area_width + 1, grid_spacing)

            for _ in range(self.max_p_as):
                x = np.random.choice(grid_points_x)
                y = np.random.choice(grid_points_y)
                self.pas.append((x, y))

        # Initialize assignments based on client proximity and capacity
        pa_bandwidth_usage = {i: 0 for i in range(self.max_p_as)}

        for index, client in self.clients.iterrows():
            assigned = False
            distances = [np.sqrt((pa[0] - client['x'])**2 + (pa[1] - client['y'])**2) for pa in self.pas]
            possible_pas = sorted(range(len(distances)), key=lambda k: distances[k])

            for pa_index in possible_pas:
                if distances[pa_index] <= self.max_distance and pa_bandwidth_usage[pa_index] + client['bandwidth'] <= self.pa_capacity:
                    self.assignments.append(pa_index)
                    pa_bandwidth_usage[pa_index] += client['bandwidth']
                    assigned = True
                    break

            if not assigned:
                # If no PA can accommodate the client, don't assign it
                self.assignments.append(-1)

    def plot_initial_solution(self):
        x_pos, y_pos = zip(*self.pas)
        plt.figure(figsize=(8, 8))
        plt.scatter(x_pos, y_pos, alpha=0.8, color='red')
        plt.title('Distribuição Espacial dos PAs na Solução Inicial')
        plt.xlabel('Posição X')
        plt.ylabel('Posição Y')
        plt.grid(True, which='major', linestyle='-', linewidth=0.5)
        plt.axis([0, 400, 0, 400])
        plt.xticks(range(0, 401, 25))
        plt.yticks(range(0, 401, 25))
        plt.minorticks_on()
        plt.grid(True, which='minor', linestyle=':', linewidth=0.5)

"""Solução Inicial"""

def sol_inicial(probdata, use_constructive_heuristic=True, qtd_pas_inicial=20):

    solution = ProblemData(
        clients=probdata.clients,
        max_p_as=probdata.max_p_as,
        pa_capacity=probdata.pa_capacity,
        max_distance=probdata.max_distance,
        lambda_exposure=probdata.lambda_exposure,
        gamma=probdata.gamma
    )

    solution.initialize_solution(use_constructive_heuristic, qtd_pas_inicial)
    # solution.plot_initial_solution()

    return solution

"""Modelando Função Objetivo 1"""

def fobj1(solution, probdata):
    active_pas = set() # Inicialize active PAs
    number_of_clients = len(probdata.clients)
    allowed_unserved = int(0.02 * number_of_clients)  # 2% of the clientes it's allowed to be unserved
    unserved_clients = 0
    total_penalty = 0  # Inicialize penalty

    for client_index, pa_index in enumerate(solution.assignments):
        if pa_index != -1:
            # Client info
            client = probdata.clients.iloc[client_index]
            pa = solution.pas[pa_index]

            # Verify distance
            distance = np.sqrt((pa[0] - client['x'])**2 + (pa[1] - client['y'])**2)

            # Add active PA
            active_pas.add(pa_index)
        else:
            unserved_clients += 1

    # Penalty for exceed the limit of unserved clients
    if unserved_clients > allowed_unserved:
        total_penalty += (unserved_clients*100)

    # Sum active PA's and penalty
    solution.fitness = len(active_pas) + total_penalty

    return solution.fitness

"""Modelando Função Objetivo 2"""

def fobj2(solution, probdata):
    active_pas = set() # Inicialize active PAs
    number_of_clients = len(probdata.clients)
    allowed_unserved = int(0.02 * number_of_clients)  # 2% of the clientes it's allowed to be unserved
    unserved_clients = 0
    total_distance = 0 # Inicialize distance
    total_penalty = 0  # Inicialize penalty

    for client_index, pa_index in enumerate(solution.assignments):
        if pa_index != -1:
            # # Client info
            client = probdata.clients.iloc[client_index]
            pa = solution.pas[pa_index]

            # Verify distance
            distance = np.sqrt((pa[0] - client['x'])**2 + (pa[1] - client['y'])**2)

            # Add active PA
            active_pas.add(pa_index)

            #Add distance
            total_distance += distance
        else:
            unserved_clients += 1

    if unserved_clients > allowed_unserved:
        total_penalty += (unserved_clients*10000)

    # Sum distance and penalty
    solution.fitness = total_distance + total_penalty
    
    return solution.fitness

"""Neighborhood Change"""

def neighborhoodChange(x, y, k):
    if y.fitness < x.fitness or (y.fitness == x.fitness and np.random.rand() < 0.5):
        x = cp.deepcopy(y)
        k = 1
    else:
        k += 1
    return x, k

"""Vizinhanças"""

def shake(solution, k, probdata):
    np.random.seed()

    new_solution = cp.deepcopy(solution)  # Copy the solution to change it
    grid_spacing = 5
    area_width = 400
    area_height = 400
    # Randomly Realocate  PA's
    if k == 1:
            pa_index = np.random.randint(len(new_solution.pas))
            pa = new_solution.pas[pa_index]
            if pa[0] != 999:
              new_x = np.random.choice(range(max(0,pa[0]-10), min(area_width+1,pa[0]+11), grid_spacing))
              new_y = np.random.choice(range(max(0,pa[1]-10), min(area_height+1,pa[1]+11), grid_spacing))
              new_solution.pas[pa_index] = (new_x, new_y)

    elif k == 2:
            pa_index = np.random.randint(len(new_solution.pas))
            pa = new_solution.pas[pa_index]
            if pa[0] != 999:
              new_x = np.random.choice(range(max(0,pa[0]-50), min(area_width+1,pa[0]+51), grid_spacing))
              new_y = np.random.choice(range(max(0,pa[1]-50), min(area_height+1,pa[1]+51), grid_spacing))
              new_solution.pas[pa_index] = (new_x, new_y)

    elif k == 3:
            if np.random.rand() < 0.5:
              stop_while = False
              i = len(new_solution.pas)
              while stop_while == False and i > 0:
                pa_index = np.random.randint(len(new_solution.pas))
                pa = new_solution.pas[pa_index]
                if pa[0] != 999:
                  new_x = 999
                  new_y = 999
                  new_solution.pas[pa_index] = (new_x, new_y)
                  stop_while = True
                else:
                  stop_while = False
                i -= 1
            else:
              i = len(new_solution.pas)
              stop_while = False
              while stop_while == False and i > 0:
                pa_index = np.random.randint(len(new_solution.pas))
                pa = new_solution.pas[pa_index]
                if pa[0] == 999:
                  new_x = np.random.choice(range(0, area_width + 1, grid_spacing))
                  new_y = np.random.choice(range(0, area_height + 1, grid_spacing))
                  new_solution.pas[pa_index] = (new_x, new_y)
                  stop_while = True
                else:
                  stop_while = False
                i -= 1

    # Initialize assignments based on client proximity and capacity
    new_solution.assignments = []
    pa_bandwidth_usage = {i: 0 for i in range(new_solution.max_p_as)}

    for index, client in new_solution.clients.iterrows():
        assigned = False
        distances = [np.sqrt((pa[0] - client['x'])**2 + (pa[1] - client['y'])**2) for pa in new_solution.pas]
        possible_pas = sorted(range(len(distances)), key=lambda k: distances[k])

        for pa_index in possible_pas:
           if distances[pa_index] <= new_solution.max_distance and pa_bandwidth_usage[pa_index] + client['bandwidth'] <= new_solution.pa_capacity:
              new_solution.assignments.append(pa_index)
              pa_bandwidth_usage[pa_index] += client['bandwidth']
              assigned = True
              break

        if not assigned:
           # If no PA can accommodate the client, don't assign it
           new_solution.assignments.append(-1)

    pa_counts = {}
    for pa_id in new_solution.assignments:
      if pa_id != -1:
            if pa_id in pa_counts:
                pa_counts[pa_id] += 1
            else:
                pa_counts[pa_id] = 1
    # Verificar modems com menos de 3 alocações
    pa_para_desalocar = [modem for modem, count in pa_counts.items() if count < 5]

    # Desalocar clientes dos modems com menos de 3 alocações
    new_solution.assignments = [-1 if modem in pa_para_desalocar else modem for modem in new_solution.assignments]


    return new_solution

"""Best Improvement"""
def bvns(current_solution, kmax, probdata):
    best_solution = cp.deepcopy(current_solution)

    for i in range(1, kmax + 1):
        neighbor_solution = shake(best_solution, i, probdata) 
        if neighbor_solution.fitness < best_solution.fitness:
            best_solution = neighbor_solution
    
    return best_solution



def bestImprovement(fobj, x, probdata, approachinfo, maxeval=1000):
    # Contador do número de soluções candidatas avaliadas
    num_sol_avaliadas = 0

    # Máximo número de soluções candidatas avaliadas
    max_num_sol_avaliadas = maxeval

    # Número de estruturas de vizinhanças definidas
    kmax = 4

    # Avalia solução inicial
    x = fobj(x, approachinfo)
    num_sol_avaliadas += 1

    # Ciclo iterativo do método
    while num_sol_avaliadas < max_num_sol_avaliadas:
        k = 1
        while k <= kmax:        
            y = shake(x, k, probdata)
            y = fobj(y, approachinfo)
            z = bvns(y, 4, probdata) # heurística de busca local
            num_sol_avaliadas += 1
            
            x, k = neighborhoodChange(x, z, k)
    
    return x


def obj_functions(x, w):
    probdata = ProblemData(
        clients=clientes_dataset,
        max_p_as=30,
        pa_capacity=54,
        max_distance=85,
        lambda_exposure=1,
        gamma=1
    )
    
    f1_fitness = fobj1(x, probdata) # Já obtem o valor de fitness para f1 devidamente penalizado
    f2_fitness = fobj2(x, probdata) # Já obtem o valor de fitness para f2 devidamente penalizado
    
    # Calcula os valores normalizados de fitness
    f1_fitness_normalizado = normalize(f1_fitness, min_f1, max_f1)
    f2_fitness_normalizado = normalize(f2_fitness, min_f2, max_f2)

    x.f1_fitness = f1_fitness_normalizado
    x.f2_fitness = f2_fitness_normalizado

    # x.total_distance = getSumDistanceClientsAndPAs(x.assignments)
    
    # Calcula o fitness da otimização multiobjetivo (com os valores normalizados)
    x.fitness = w[0]*f1_fitness_normalizado + w[1]*f2_fitness_normalizado

    return x

'''
Função para normalizar os valores de fitness
'''
def normalize(value, min_value, max_value):
    return (value - min_value) / (max_value - min_value)

'''
Implementa a função soma ponderada
'''
def pw_function(x, approachinfo):
    x = obj_functions(x, approachinfo.w)
    x.single_objective_value = np.dot(approachinfo.w, np.transpose(np.array(x.fitness)))

    return x

def is_dominated(sol_a, sol_b):
    """Retorna True se sol_a for dominada por sol_b, caso contrário False."""
    return all(x >= y for x, y in zip(sol_a, sol_b)) and any(x > y for x, y in zip(sol_a, sol_b))

def find_non_dominated_solutions(solutions):
    """Retorna uma lista de soluções não dominadas."""
    non_dominated = []
    for i, sol_a in enumerate(solutions):
        dominated = False
        for j, sol_b in enumerate(solutions):
            if i != j and is_dominated(sol_a, sol_b):
                dominated = True
                break
        if not dominated:
            non_dominated.append(sol_a)
    return non_dominated


def plot_solutions(all_solutions, non_dominated_solutions, title = "Soluções e Soluções Não Dominadas"):
    # Separando os valores de fitness de f1 e f2 para todas as soluções
    all_f1 = [sol[0] for sol in all_solutions]
    all_f2 = [sol[1] for sol in all_solutions]
    
    # Separando os valores de fitness de f1 e f2 para as soluções não dominadas
    nd_f1 = [sol[0] for sol in non_dominated_solutions]
    nd_f2 = [sol[1] for sol in non_dominated_solutions]
    
    # Criando o gráfico de dispersão
    plt.figure(figsize=(10, 6))
    
    # Plotando todas as soluções
    plt.scatter(all_f1, all_f2, c='blue', label='Todas as soluções', alpha=0.5)
    
    # Destacando as soluções não dominadas
    plt.scatter(nd_f1, nd_f2, c='red', label='Soluções não dominadas', edgecolors='black', s=100)
    
    # Adicionando título e rótulos aos eixos
    plt.title(title)
    plt.xlabel('Fitness f1')
    plt.ylabel('Fitness f2')
    
    # Adicionando legenda
    plt.legend()
    
    # Mostrando o gráfico
    plt.show()


def main():
    probdata = ProblemData(
            clients=clientes_dataset,
            max_p_as=30,
            pa_capacity=54,
            max_distance=85,
            lambda_exposure=1,
            gamma=1
        )
    
    archive = Struct()
    archive.sol = []
    archive.fitpen = []

    # Armazena dados da estratégia de otimização mono-objetivo
    approachinfo = Struct()

    num_sol_avaliadas = 0
    max_sol = 20
    while num_sol_avaliadas < max_sol:
        N = 20
        num_sol_avaliadas += 1
        for i in np.arange(0, N, 1):
            w = np.random.random(size=2)  # gera um vetor de pesos aleatórios
            w = w/sum(w)                  # normaliza o vetor de pesos 
        
            # Gera solução inicial
            x = sol_inicial(
                probdata,
                use_constructive_heuristic=True,
                qtd_pas_inicial = 15)
        
            approachinfo.w = w
            x = bestImprovement(pw_function, x, probdata, approachinfo, maxeval=200)
        
            archive.fitpen.append((x.f1_fitness, x.f2_fitness))
        
        non_dominated_solutions = find_non_dominated_solutions(archive.fitpen)
        archive.sol.extend(non_dominated_solutions)

    plot_solutions(archive.fitpen, archive.sol)
    temp = find_non_dominated_solutions(archive.sol)
    plot_solutions(archive.fitpen, temp, title = "Soma ponderada")
    print("Soluções não dominadas:", archive.sol)
    print("Todas as soluções: ", archive.fitpen)






if __name__ == "__main__":
    main()